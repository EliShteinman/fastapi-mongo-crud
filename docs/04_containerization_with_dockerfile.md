### **קובץ הדרכה: `docs/04_containerization_with_dockerfile.md`**

#### **1. מטרת השלב**

מטרת שלב זה היא לבצע "קונטיינריזציה" לאפליקציה שלנו. אנו יוצרים קובץ `Dockerfile`, שהוא למעשה "מתכון" שמגדיר איך לבנות אימג' (image) נייד ועצמאי של האפליקציה. אימג' זה מכיל את כל מה שהאפליקציה צריכה כדי לרוץ – מערכת הפעלה מינימלית, סביבת פייתון, כל הספריות הדרושות, ואת קוד המקור שלנו. תהליך זה מבטיח שהאפליקציה תרוץ באותה צורה בדיוק על המחשב של המפתח, בשרת הבדיקות, ובסביבת ה-Production ב-OpenShift.

---

#### **2. הסבר מעמיק על הפעולות שבוצעו**

יצרנו קובץ `Dockerfile` המכיל סדרה של הוראות, שלכל אחת מהן תפקיד מוגדר:

1.  **`FROM python:3.11-slim`**:
    *   **פעולה:** כל `Dockerfile` חייב להתחיל מהוראת `FROM`, הקובעת את אימג' הבסיס.
    *   **הסבר:** בחרנו באימג' הרשמי של פייתון בגרסה 3.11, בגרסת `slim`. גרסת `slim` מכילה רק את הרכיבים ההכרחיים להרצת פייתון, ולכן היא קטנה יותר מגרסת ברירת המחדל, מה שמוביל לאימג' סופי קטן יותר ומהיר יותר להורדה. בחירת גרסת פייתון ספציפית (`3.11`) מבטיחה עקביות ומונעת שגיאות תאימות.

2.  **`WORKDIR /app`**:
    *   **פעולה:** מגדירה את תיקיית העבודה הפעילה בתוך הקונטיינר.
    *   **הסבר:** כל הפקודות שיבואו אחריה (כמו `COPY` ו-`RUN`) יתבצעו ביחס לנתיב זה (`/app`). זהו נוהג מומלץ השומר על סדר בתוך מערכת הקבצים של הקונטיינר.

3.  **`COPY requirements.txt .` ו-`RUN pip install ...`**:
    *   **פעולה:** שתי פקודות אלו עובדות יחד: הראשונה מעתיקה את קובץ התלויות בלבד, והשנייה מתקינה אותן.
    *   **הסבר (אופטימיזציה חשובה):** אנו מבצעים את הפעולות האלה לפני העתקת קוד המקור שלנו בכוונה. Docker בונה אימג'ים ב"שכבות". אם קבצים בשכבה מסוימת לא משתנים בין בנייה לבנייה, Docker ישתמש בשכבה הזו מהמטמון (cache). קובץ התלויות (`requirements.txt`) משתנה לעתים רחוקות, בעוד שקוד המקור משתנה כל הזמן. על ידי הפרדה זו, שכבת התקנת התלויות (שהיא לרוב איטית) תיטען מהמטמון ברוב הבניות, מה שמאיץ משמעותית את תהליך הפיתוח.

4.  **`COPY ./app /app/app`**:
    *   **פעולה:** מעתיקה את כל תיקיית `app` מהמחשב המקומי שלנו לתוך תיקיית `/app/app` בקונטיינר.
    *   **הסבר:** פעולה זו מכניסה את כל קוד המקור של האפליקציה לתוך האימג'.

5.  **`EXPOSE 8080`**:
    *   **פעולה:** זוהי הוראה תיעודית שאומרת ל-Docker שהקונטיינר, בזמן ריצה, יאזין לתעבורה בפורט 8080.
    *   **הסבר:** היא לא פותחת את הפורט בפועל לעולם החיצון, אבל היא מהווה מידע חשוב עבור מפתחים ועבור פלטפורמות כמו OpenShift, שלעתים קרובות מצפות מאפליקציות להאזין בפורט זה.

6.  **`CMD ["uvicorn", "app.main:app", ...]`**:
    *   **פעולה:** זוהי הפקודה שתרוץ **אוטומטית כאשר הקונטיינר יופעל**.
    *   **הסבר:** היא מריצה את שרת ה-`uvicorn`. הנתיב `app.main:app` אומר לשרת: "לך לחבילה `app`, בתוכה לקובץ `main.py`, ומצא שם את אובייקט ה-FastAPI שנקרא `app`". הדגל `--host 0.0.0.0` חיוני כדי שהשרת יהיה נגיש מחוץ לקונטיינר.

---

#### **3. חלופות ושיקולים**

*   **בנייה רב-שלבית (Multi-stage builds):**
    *   **חלופה:** ניתן לבנות `Dockerfile` עם מספר שלבי `FROM`. למשל, שלב ראשון יכול לשמש להתקנת תלויות פיתוח והרצת בדיקות, והשלב הסופי יעתיק רק את קוד המקור והתלויות הנחוצות לסביבת הייצור לאימג' בסיס נקי.
    *   **יתרונות:** יוצר אימג' סופי קטן ובטוח יותר, שמכיל רק את מה שהכרחי לריצה.
    *   **חסרונות:** מורכב יותר לכתיבה. לפרויקט זה, בנייה חד-שלבית היא פשוטה ומספיקה.
*   **ארכיטקטורת מעבד (`--platform linux/amd64`):**
    *   **שיקול:** כפי שראינו בפרויקט הקודם, אם מפתחים על מחשב Mac עם מעבד M-series (ארכיטקטורת `arm64`) ופורסים לסביבת ענן סטנדרטית (ארכיטקטורת `amd64`), יש צורך לציין במפורש את פלטפורמת היעד בזמן הבנייה באמצעות `docker buildx`. נתייחס לכך בפקודות הבנייה בשלב הבא.
