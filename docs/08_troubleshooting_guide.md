### **קובץ הדרכה: `docs/08_troubleshooting_guide.md`**

#### **1. מטרת המדריך**

מדריך זה מרכז פתרונות לבעיות נפוצות שעלולות להתרחש במהלך הפריסה וההרצה של האפליקציה ב-OpenShift. הכלל החשוב ביותר בדיבאגינג הוא: **הלוגים הם החברים הכי טובים שלכם.**

---

#### **2. הבעיה: ה-Pods קורסים או במצב `CrashLoopBackOff` / `Error`**

זהו הסימפטום הנפוץ ביותר. הוא אומר שהקונטיינר הצליח להתחיל לרוץ, אבל התהליך הראשי בתוכו (האפליקציה שלנו) קרס מיד.

**שלב 1: שלוף את הלוגים מהריצה הכושלת**

הפקודה החשובה ביותר היא `oc logs`. מכיוון שה-Pod קורס בלולאה, אנו צריכים להשתמש בדגל `--previous` כדי לראות את הלוגים מהריצה האחרונה שנכשלה.

1.  מצא את שם ה-Pod המלא: `oc get pods`
2.  הרץ את הפקודה (החלף את שם ה-Pod):
    ```bash
    oc logs <full-pod-name> --previous
    ```

**שלב 2: נתח את שגיאת ה-Traceback**

הפלט של הלוגים יכיל `Traceback` של פייתון. קרא את השורות האחרונות כדי להבין את שורש הבעיה.

##### **תרחיש א': שגיאת `ImagePullBackOff`**

*   **הסימפטום:** ה-Pod אפילו לא מגיע למצב `Running`. הוא תקוע ב-`ImagePullBackOff` או `ErrImagePull`.
*   **הסיבה:** OpenShift לא מצליח למשוך את האימג' מה-Registry (Docker Hub).
*   **פתרונות:**
    1.  ודא ששם האימג' בקובץ ה-`Deployment` נכון (שם משתמש, שם אפליקציה, ותג).
    2.  ודא שדחפת את האימג' ל-Docker Hub לפני הפריסה.
    3.  ודא שהאימג' ב-Docker Hub הוא ציבורי (public), או שהגדרת `imagePullSecret` עבור registry פרטי.
    4.  **זו הבעיה שפתרנו באמצעות שימוש בתגים ייחודיים במקום `:latest`**, מה שמבטיח ש-OpenShift תמיד מושך את הגרסה הנכונה.

##### **תרחיש ב': `ValidationError` של Pydantic (כמו שחווינו)**

*   **הסימפטום:** ה-Pod קורס מיד עם `pydantic_core._pydantic_core.ValidationError`.
*   **הסיבה:** יש חוסר התאמה בין משתני הסביבה שהאפליקציה מצפה לקבל (כפי שהוגדרו ב-`app/core/config.py`) לבין מה שסופק לה בקובץ ה-`Deployment`.
*   **פתרונות:**
    1.  בדוק את הלוגים כדי לראות איזה שדה חסר.
    2.  השווה את קובץ ה-`Deployment` (`05-fastapi-deployment.yaml`) לקלאס `Settings` בקוד. ודא שכל השדות הנדרשים מסופקים.
    3.  **הפתרון שלנו היה לפשט את `Settings` ולהעביר את לוגיקת בניית ה-URI לקובץ `database.py`**, מה שמנע את הבלבול.

##### **תרחיש ג': `ServerSelectionTimeoutError` או שגיאת חיבור אחרת**

*   **הסימפטום:** ה-Traceback מצביע על שגיאת timeout או `connection refused` בעת ניסיון החיבור ל-MongoDB.
*   **הסיבה:** האפליקציה לא מצליחה למצוא את מסד הנתונים ברשת או להתחבר אליו.
*   **פתרונות:**
    1.  **בדוק את שם ה-Service:** ודא שהערך של `MONGO_HOST` ב-Deployment של FastAPI (למשל, `"mongo-db-service"`) זהה בדיוק לשם ה-`Service` שהוגדר ב-`04-mongo-service.yaml`.
    2.  **ודא שה-MongoDB Pod רץ:** הרץ `oc get pods` וודא שה-Pod של MongoDB במצב `Running 1/1`.
    3.  **ודא שה-Service מקושר ל-Pod:** הרץ `oc describe service mongo-db-service` ובדוק תחת `Endpoints` אם מופיעה כתובת ה-IP של ה-Pod של MongoDB. אם לא, יש בעיית `selector` או `labels`.
    4.  **סדר עלייה:** הוספת `oc wait` לסקריפט הפריסה, כפי שעשינו, מבטיחה שהאפליקציה תנסה לעלות רק אחרי שמסד הנתונים מוכן.

