### **קובץ הדרכה: `docs/06_fastapi_openshift_deployment.md`**

#### **1. מטרת השלב**

מטרת שלב זה היא לפרוס את אפליקציית ה-FastAPI שלנו ל-OpenShift. אנו יוצרים את שלושת קבצי ה-YAML האחרונים הדרושים: `Deployment` להרצת קונטיינר האפליקציה, `Service` לחשיפתה ברשת הפנימית של הקלאסטר, ו-`Route` לחשיפתה לאינטרנט. שלב זה מחבר בין קוד האפליקציה שלנו לתשתית מסד הנתונים שכבר הקמנו.

---

#### **2. הסבר מעמיק על האובייקטים שנוצרו**

1.  **Deployment (`05-fastapi-deployment.yaml`):**
    *   **מטרה:** קובץ זה מגדיר כיצד להריץ את שירות ה-FastAPI שלנו.
    *   **`replicas: 2`**: הגדרנו שני עותקים של האפליקציה. OpenShift יריץ שני Pods זהים במקביל. זה מספק **זמינות גבוהה (High Availability)**. אם Pod אחד קורס או נמצא בתהליך עדכון, ה-Pod השני ימשיך לשרת בקשות, והמשתמשים לא יחוו הפסקה בשירות.
    *   **`image: "docker.io/..."`**: כאן אנו מציינים את הנתיב המלא לאימג' שבנינו ודחפנו ל-Docker Hub.
    *   **`imagePullPolicy: Always`**: זוהי הגדרה חשובה שאומרת ל-OpenShift תמיד לנסות למשוך מחדש את האימג' מ-Docker Hub בעת יצירת Pod חדש. זה מבטיח שאנחנו תמיד מריצים את הגרסה המעודכנת ביותר של הקוד שלנו.
    *   **חיבור ל-MongoDB (`env`):**
        *   כאן מתבצע החיבור הקריטי למסד הנתונים. אנו מגדירים את משתני הסביבה שאפליקציית הפייתון שלנו מצפה להם (`MONGO_URI`, `MONGO_DB_NAME`).
        *   **`valueFrom: secretKeyRef:`**: אנו שולפים את שם המשתמש, הסיסמה ושם מסד הנתונים ישירות מה-`Secret` שיצרנו בשלב הקודם.
        *   **בניית ה-URI:** שימו לב לדרך שבה בנינו את ה-`MONGO_URI`: `"mongodb://$(MONGO_INITDB_ROOT_USERNAME):$(MONGO_INITDB_ROOT_PASSWORD)@mongo-service:27017"`. התחביר `$(VAR_NAME)` מאפשר לנו להשתמש במשתני סביבה אחרים (שגם הם מוזרקים מה-Secret) כדי לבנות את הערך. שם ה-host הוא `mongo-service` – שם ה-Service של MongoDB, מה שמבטיח תקשורת פנימית יציבה בקלאסטר.

2.  **Service (`06-fastapi-service.yaml`):**
    *   **מטרה:** בדומה לשירות של MongoDB, גם כאן אנו יוצרים נקודת גישה פנימית וקבועה עבור ה-Pods של FastAPI.
    *   **ההיגיון:** ה-Service מאגד את שני ה-Pods שהגדרנו ב-Deployment תחת כתובת DNS פנימית אחת (`fastapi-service`). ה-Route, שניצור בשלב הבא, יפנה את התעבורה לשירות הזה, והשירות יפזר את העומס (Load Balancing) באופן אוטומטי בין שני ה-Pods הזמינים.

3.  **Route (`07-fastapi-route.yaml`):**
    *   **מטרה:** זהו האובייקט הייחודי ל-OpenShift שחושף את השירות שלנו לעולם החיצון (לאינטרנט).
    *   **`to: ... name: fastapi-service`**: ההגדרה המרכזית. היא אומרת ל-Route לנתב את כל התעבורה הנכנסת אל ה-`Service` הפנימי שיצרנו.
    *   **`tls: termination: edge`**: הגדרה זו מורה ל-OpenShift לנהל עבורנו את תעודת ה-SSL/TLS. התקשורת מהדפדפן של המשתמש ועד ל-OpenShift תהיה מוצפנת (HTTPS). OpenShift יפענח את התעבורה וישלח אותה כאותיות HTTP רגילות אל ה-Pod שלנו. זה מפשט את הקוד שלנו, שלא צריך להתמודד עם ניהול תעודות SSL.

---

#### **3. חלופות ושיקולים**

*   **שימוש ב-`oc new-app` עבור FastAPI:**
    *   **חלופה:** ניתן היה לפרוס את האפליקציה באמצעות פקודה אחת, תוך שימוש ביכולת Source-to-Image (S2I) של OpenShift, אם הקוד היה במאגר Git חיצוני.
        ```bash
        # דוגמה לפריסה מ-Git, כולל חיבור למשתני סביבה
        oc new-app python:3.11~https://github.com/your_user/your_repo.git \
          --name=fastapi-app \
          -e MONGO_URI="mongodb://user:pass@mongo-service:27017" \
          -e MONGO_DB_NAME="mydatabase"
        ```
    *   **יתרונות:** פשוט מאוד, לא דורש `Dockerfile` או בנייה מקומית. OpenShift בונה את האימג' בעצמו.
    *   **חסרונות:** פחות שליטה על תהליך הבנייה. הגישה של בניית `Dockerfile` בעצמנו (כפי שעשינו) היא גמישה יותר ומאפשרת התאמה מדויקת של סביבת הריצה. בנוסף, היא לא מתאימה אם הקוד לא נמצא ב-Git.

*   **שימוש ב-Ingress במקום Route:**
    *   **חלופה:** `Ingress` הוא אובייקט Kubernetes סטנדרטי לחשיפת שירותים. `Route` הוא אובייקט ספציפי ומתקדם יותר של OpenShift.
    *   **שיקול:** אם המטרה היא ניידות מלאה בין כל סוגי ה-Kubernetes, שימוש ב-`Ingress` עשוי להיות עדיף. עם זאת, `Route` מציע יכולות מתקדמות "מובנות" ב-OpenShift, כמו ניהול תעודות אוטומטי ופיצול תעבורה (Traffic Splitting), ולכן הוא לרוב הבחירה המועדפת בסביבת OpenShift.
