### **קובץ הדרכה: `docs/07_deployment_automation.md`**

#### **1. מטרת השלב**

מטרת שלב זה היא לאחד את כל תהליך הפריסה המורכב לכדי סקריפט אוטומטי אחד, פשוט להרצה. אוטומציה היא עיקרון יסוד בעולם ה-DevOps, והיא מפחיתה טעויות אנוש, מבטיחה חזרתיות, ומאיצה את תהליך הפריסה. הסקריפט שיצרנו, `deploy.sh`, יבצע את כל הפעולות הנדרשות בסדר הנכון: החל מבניית האימג' ודחיפתו, דרך יצירת כל משאבי התשתית ב-OpenShift, ועד להצגת הכתובת הסופית של האפליקציה.

---

#### **2. הסבר מעמיק על מבנה הסקריפט**

הסקריפט `deploy.sh` כתוב בשפת `bash` ומכיל מספר טכניקות ופקודות חשובות:

1.  **תצורה (`Configuration`):**
    *   בתחילת הסקריפט ריכזנו את כל המשתנים שמשתמש עשוי להצטרך לשנות, כמו `DOCKERHUB_USERNAME`. ריכוז הגדרות בתחילת הקובץ הוא נוהג מומלץ שהופך את הסקריפט לקל יותר לתחזוקה והתאמה.

2.  **עצירה בשגיאה (`set -e`):**
    *   זוהי פקודה חשובה מאוד בסקריפטים של אוטומציה. היא מורה ל-Shell לעצור את ריצת הסקריפט **מיד** אם פקודה כלשהי נכשלת (מחזירה קוד יציאה שונה מאפס). זה מונע מצב שבו חלק מהתהליך נכשל אבל הסקריפט ממשיך לרוץ ומבצע פעולות חלקיות שעלולות לגרום לבעיות.

3.  **פונקציות עזר (`print_header`):**
    *   השימוש בפונקציות להדפסת כותרות הופך את הפלט של הסקריפט לקריא ומסודר הרבה יותר. קל לעקוב אחרי השלבים ולהבין מה מתבצע בכל רגע נתון.

4.  **בנייה ודחיפה (`docker buildx build ... --push`):**
    *   בחרנו להשתמש בפקודה המשולבת `--push` מכיו-ן שהיא יעילה יותר. היא בונה את האימג' עבור הארכיטקטורה הנכונה (`linux/amd64`) ומיד דוחפת אותו ל-Docker Hub, וחוסכת לנו פקודה נפרדת.

5.  **החלפה דינמית של שם משתמש (`sed ... | oc apply -f -`):**
    *   **הבעיה:** קובץ ה-`05-fastapi-deployment.yaml` מכיל placeholder בשם `YOUR_DOCKERHUB_USERNAME`. אנחנו לא רוצים שכל משתמש יצטרך לערוך את הקובץ ידנית.
    *   **הפתרון:** אנו משתמשים בפקודת `sed` (Stream Editor), כלי רב עוצמה לעריכת טקסט.
        *   `sed "s|YOUR_DOCKERHUB_USERNAME|${DOCKERHUB_USERNAME}|g"`: פקודה זו קוראת את קובץ ה-YAML, מחפשת את המחרוזת `YOUR_DOCKERHUB_USERNAME`, ומחליפה אותה בערך של המשתנה `${DOCKERHUB_USERNAME}` שהגדרנו בתחילת הסקריפט.
        *   `| oc apply -f -`: הפלט של פקודת `sed` (שהוא תוכן ה-YAML המתוקן) מועבר דרך "צינור" (pipe) ישירות לקלט הסטנדרטי של הפקודה `oc apply`. הדגל `-f -` אומר ל-`oc` לקרוא את המניפסט מהקלט הסטנדרטי במקום מקובץ.
    *   **התוצאה:** אנו פורסים את ה-Deployment עם הנתיב הנכון לאימג', מבלי צורך לשנות את קובץ המקור ב-Git. זוהי טכניקה נפוצה מאוד בסקריפטים של CI/CD.

6.  **שליפת ה-URL בסיום (`oc get route ...`):**
    *   בסוף התהליך, במקום רק להדפיס למשתמש מה להריץ, הסקריפט שולף את כתובת ה-URL הסופית של האפליקציה באופן אוטומטי באמצעות `oc get route` עם פורמט פלט של `jsonpath`. זה מספק חווית משתמש טובה יותר ומונע טעויות העתקה.

---

#### **3. חלופות ושיקולים**

*   **שימוש בכלי CI/CD (כמו Jenkins, GitHub Actions, Tekton):**
    *   **חלופה:** בסביבת ייצור אמיתית, לא היינו מריצים את הסקריפט הזה ידנית מהמחשב המקומי. היינו מגדירים אותו לרוץ באופן אוטומטי בתוך מערכת CI/CD.
    *   **התהליך:** בכל פעם שמפתח דוחף `commit` חדש למאגר ה-Git, המערכת הייתה מזהה את השינוי, מריצה את הבדיקות, בונה ודוחפת את האימג' החדש, ומפעילה את פקודות ה-`oc apply` כדי לעדכן את הסביבה באופן אוטומטי.
    *   **שיקול:** Tekton הוא כלי ה-CI/CD המובנה ב-OpenShift. לימוד שלו הוא הצעד הבא הטבעי אחרי הבנת התהליך הידני.

*   **ניהול תצורה עם Kustomize או Helm:**
    *   **חלופה:** במקום להשתמש ב-`sed` כדי להחליף ערכים, יכולנו להשתמש בכלים מתקדמים יותר לניהול תצורת YAML, כמו `Kustomize` (שמובנה ב-`oc`) או `Helm`.
    *   **הסבר:** כלים אלו מאפשרים להגדיר קובץ YAML "בסיסי", וליצור "שכבות" (overlays) או "ערכים" (values) שונים עבור כל סביבה (פיתוח, בדיקות, ייצור). הם מספקים דרך מובנית ונקייה יותר להתאים את אותם מניפסטים לסביבות שונות.
