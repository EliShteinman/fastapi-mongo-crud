### חלק 2: קובץ מתוקן `docs/07_deployment_automation.md`

הנה התוכן המלא של קובץ ההסבר על האוטומציה, `docs/07_deployment_automation.md`. הוא מעודכן כדי להסביר את החשיבות של שימוש בתג ייחודי לאימג'.

---
### **קובץ הדרכה: `docs/07_deployment_automation.md`**

#### **1. מטרת השלב**

מטרת שלב זה היא לאחד את כל תהליך הפריסה המורכב לכדי סקריפט אוטומטי אחד, פשוט להרצה. אוטומציה היא עיקרון יסוד בעולם ה-DevOps, והיא מפחיתה טעויות אנוש, מבטיחה חזרתיות, ומאיצה את תהליך הפריסה. הסקריפט שיצרנו, `deploy.sh`, יבצע את כל הפעולות הנדרשות בסדר הנכון: החל מבניית האימג' ודחיפתו, דרך יצירת כל משאבי התשתית ב-OpenShift, ועד להצגת הכתובת הסופית של האפליקציה.

---

#### **2. הסבר מעמיק על מבנה הסקריפט**

הסקריפט `deploy.sh` כתוב בשפת `bash` ומכיל מספר טכניקות ופקודות חשובות:

1.  **תצורה (`Configuration`):**
    *   בתחילת הסקריפט ריכזנו את כל המשתנים שמשתמש עשוי להצטרך לשנות, כמו `DOCKERHUB_USERNAME`. ריכוז הגדרות בתחילת הקובץ הוא נוהג מומלץ שהופך את הסקריפט לקל יותר לתחזוקה והתאמה.

2.  **עצירה בשגיאה (`set -e`):**
    *   זוהי פקודה חשובה מאוד בסקריפטים של אוטומציה. היא מורה ל-Shell לעצור את ריצת הסקריפט **מיד** אם פקודה כלשהי נכשלת (מחזירה קוד יציאה שונה מאפס). זה מונע מצב שבו חלק מהתהליך נכשל אבל הסקריפט ממשיך לרוץ ומבצע פעולות חלקיות שעלולות לגרום לבעיות.

3.  **פונקציות עזר (`print_header`):**
    *   השימוש בפונקציות להדפסת כותרות הופך את הפלט של הסקריפט לקריא ומסודר הרבה יותר. קל לעקוב אחרי השלבים ולהבין מה מתבצע בכל רגע נתון.

4.  **תג גרסה ייחודי (`IMAGE_TAG`):**
    *   הסקריפט יוצר תג (tag) ייחודי לכל אימג' חדש, באמצעות ה-hash של ה-commit האחרון ב-Git.
    *   **היגיון:** שימוש בתג קבוע כמו `:latest` הוא פרקטיקה גרועה שמובילה לבעיות. פלטפורמת ה-Orchestration (כמו OpenShift) עלולה לא לזהות שאימג' חדש נדחף ולהמשיך להשתמש בגרסה ישנה מהמטמון (cache) שלה. שימוש בתג ייחודי (`:a1b2c3d`) מכריח את OpenShift למשוך את הגרסה החדשה והנכונה בכל פריסה.

5.  **החלפה דינמית של ערכים (`sed ... | oc apply -f -`):**
    *   **הבעיה:** קובץ ה-`05-fastapi-deployment.yaml` מכיל שני ערכים זמניים (placeholders): `YOUR_DOCKERHUB_USERNAME` ו-`:latest`. אנחנו צריכים להחליף אותם בערכים הנכונים בזמן הריצה, מבלי לערוך את הקובץ ידנית.
    *   **הפתרון:** אנו משתמשים בפקודת `sed` עם שני ביטויי החלפה:
        *   `sed -e "s|YOUR_DOCKERHUB_USERNAME|${DOCKERHUB_USERNAME}|g"`: מחליף את שם המשתמש.
        *   `-e "s|:latest|:${IMAGE_TAG}|g"`: מחליף את התג `:latest` בתג הייחודי שיצרנו בתחילת הסקריפט.
    *   **התוצאה:** אנו פורסים את ה-Deployment עם נתיב מלא וייחודי לאימג' (למשל, `docker.io/myuser/my-app:a1b2c3d`). זה מבטיח פריסה אמינה של הגרסה הנכונה של האפליקציה.

6.  **שליפת ה-URL בסיום (`oc get route ...`):**
    *   בסוף התהליך, במקום רק להדפיס למשתמש מה להריץ, הסקריפט שולף את כתובת ה-URL הסופית של האפליקציה באופן אוטומטי באמצעות `oc get route` עם פורמט פלט של `jsonpath`. זה מספק חווית משתמש טובה יותר ומונע טעויות העתקה.

---

#### **3. חלופות ושיקולים**

*   **שימוש בכלי CI/CD (כמו Jenkins, GitHub Actions, Tekton):**
    *   **חלופה:** בסביבת ייצור אמיתית, לא היינו מריצים את הסקריפט הזה ידנית מהמחשב המקומי. היינו מגדירים אותו לרוץ באופן אוטומטי בתוך מערכת CI/CD.
    *   **התהליך:** בכל פעם שמפתח דוחף `commit` חדש למאגר ה-Git, המערכת הייתה מזהה את השינוי, מריצה את הבדיקות, בונה ודוחפת את האימג' החדש, ומפעילה את פקודות ה-`oc apply` כדי לעדכן את הסביבה באופן אוטומטי.
    *   **שיקול:** Tekton הוא כלי ה-CI/CD המובנה ב-OpenShift. לימוד שלו הוא הצעד הבא הטבעי אחרי הבנת התהליך הידני.

*   **ניהול תצורה עם Kustomize או Helm:**
    *   **חלופה:** במקום להשתמש ב-`sed` כדי להחליף ערכים, יכולנו להשתמש בכלים מתקדמים יותר לניהול תצורת YAML, כמו `Kustomize` (שמובנה ב-`oc`) או `Helm`.
    *   **הסבר:** כלים אלו מאפשרים להגדיר קובץ YAML "בסיסי", וליצור "שכבות" (overlays) או "ערכים" (values) שונים עבור כל סביבה (פיתוח, בדיקות, ייצור). הם מספקים דרך מובנית ונקייה יותר להתאים את אותם מניפסטים לסביבות שונות.
