### **קובץ הדרכה: `docs/03_api_and_main_app.md`**

#### **1. מטרת השלב**

בשלב זה, אנו מחברים את כל רכיבי הלוגיקה והנתונים שבנינו לכדי אפליקציית ווב מתפקדת. אנו יוצרים את נקודת הכניסה הראשית (`main.py`) ואת מודול ה-API (`items.py`) שמכיל את כל נקודות הקצה (Endpoints) הדרושות לביצוע פעולות CRUD מלאות. שלב זה הופך את הקוד שלנו לשירות אינטרנטי שניתן לתקשר איתו.

---

#### **2. הסבר מעמיק על הפעולות שבוצעו**

1.  **נקודת הכניסה הראשית (`app/main.py`):**
    *   **מטרה:** קובץ זה הוא ה"דבק" שמחזיק את האפליקציה יחד. הוא אחראי על יצירת מופע של FastAPI, ניהול מחזור החיים של האפליקציה, וחיבור כל מודולי ה-API (ה-Routers).
    *   **`lifespan` (ניהול מחזור חיים):** זוהי הדרך המודרנית והמומלצת ב-FastAPI לנהל קוד שצריך לרוץ בעת עליית השרת ובעת כיבויו.
        *   הקוד שלפני `yield` (במקרה שלנו, `await init_db()`) רץ **פעם אחת** כשהאפליקציה מתחילה, לפני שהיא מתחילה לקבל בקשות. זהו המקום האידיאלי לאתחל חיבורים למסדי נתונים, לטעון מודלים של Machine Learning, או לבצע כל פעולת הגדרה ראשונית אחרת.
        *   הקוד שאחרי `yield` ירוץ כשהאפליקציה נסגרת, ומאפשר לנו לבצע פעולות ניקוי, כמו סגירת חיבורים.
    *   **`app.include_router(...)`**: פקודה זו משמשת לארגון הפרויקט. במקום להגדיר את כל ה-endpoints בקובץ `main.py` אחד, אנו מגדירים אותם בקבצים נפרדים (כמו `items.py`) באמצעות `APIRouter`. פקודה זו "מייבאת" את כל ה-endpoints מהראוטר הזה ומחברת אותם לאפליקציה הראשית תחת קידומת (prefix) משותפת, כמו `/api/v1/items`. זה הופך את הקוד למודולרי וקל יותר לתחזוקה.

2.  **מודול ה-API (`app/api/items.py`):**
    *   **מטרה:** קובץ זה מכיל את כל הלוגיקה שקשורה ישירות לפרוטוקול HTTP עבור ניהול "פריטים". הוא מקבל בקשות HTTP, משתמש בסכמות ה-Pydantic שהגדרנו כדי לאמת את הנתונים, מבצע את הפעולה הנדרשת מול מסד הנתונים (באמצעות `beanie`), ומחזיר תגובת HTTP עם קוד הסטטוס המתאים.
    *   **`async` ו-`await`**: כל פונקציות ה-Endpoint הן אסינכרוניות (`async def`), וכל פעולה מול מסד הנתונים מתבצעת עם `await`. זהו לב ליבה של עבודה עם FastAPI ו-`motor`, ומאפשר לשרת לטפל ביעילות באלפי בקשות במקביל מבלי "להיתקע".
    *   **`PydanticObjectId`**: סוג נתונים מיוחד ש-`beanie` מספק. כאשר משתמשים בו בהגדרת פרמטר בנתיב (כמו `item_id`), FastAPI ו-Beanie ידאגו אוטומטית לוודא שהערך שהתקבל ב-URL הוא `ObjectId` תקין של MongoDB, וימירו אותו לאובייקט הנכון. זה חוסך לנו קוד אימות ידני.
    *   **טיפול בשגיאות (`HTTPException`):** כאשר משאב לא נמצא (למשל, בקשת `GET` לפריט עם ID שלא קיים), הקוד זורק שגיאת `HTTPException` עם קוד סטטוס `404 Not Found`. זוהי הדרך הנכונה לטפל בשגיאות ברמת ה-API ולהחזיר תגובות ברורות וסטנדרטיות ללקוח.
    *   **קודי סטטוס (`status_code`):** אנו משתמשים בקודי סטטוס HTTP ספציפיים כדי לתאר את תוצאת הפעולה, בהתאם לסטנדרט RESTful: `201 Created` עבור יצירה מוצלחת, ו-`204 No Content` עבור מחיקה מוצלחת.

---

#### **3. חלופות ושיקולים**

*   **שימוש ב-Dependency Injection:**
    *   **חלופה:** בפרויקט ה-SQL הקודם, השתמשנו רבות ב-`Depends()` של FastAPI כדי "להזריק" את סשן מסד הנתונים לכל פונקציה.
    *   **שיקול:** בארכיטקטורה שבנינו כאן עם `beanie` ו-`motor`, החיבור למסד הנתונים מנוהל באופן גלובלי ונוצר פעם אחת בעליית השרת. `beanie` מנהל את התקשורת מאחורי הקלעים דרך המודלים הסטטיים (`Item.get()`, `Item.find_all()`). לכן, אין צורך להזריק תלות של DB לכל פונקציה, מה שמפשט מאוד את הקוד של ה-Endpoints. זוהי אחת מנקודות החוזק של `beanie`.
